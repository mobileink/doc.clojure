<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN"
"http://docs.oasis-open.org/dita/dtd/topic.dtd">
<topic id="destructuring">
  <title>Destructuring</title>

  <prolog>
    <metadata>
      <keywords>
	<indexterm>Binding form</indexterm>
	<indexterm>Destructuring</indexterm>
      </keywords>
    </metadata>
  </prolog>


  <body>
    <p>
      Clojure supports abstract structural binding, often called
      destructuring, in let binding lists, fn parameter lists, and any
      macro that expands into a let or fn. The basic idea is that a
      binding-form can be a data structure literal containing symbols
      that get bound to the respective parts of the init-expr. The
      binding is abstract in that a vector literal can bind to
      anything that is sequential, while a map literal can bind to
      anything that is associative.
    </p>

    <section>
      <title>Vector Destructuring</title>
      <p>
	Vector binding-exprs allow you to bind names to parts of
	sequential things (not just vectors), like vectors, lists,
	seqs, strings, arrays, and anything that supports nth. The
	basic sequential form is a vector of binding-forms, which will
	be bound to successive elements from the init-expr, looked up
	via <codeph>nth</codeph>. In addition, and optionally, &amp;
	followed by a binding-form will cause that binding-form to be
	bound to the remainder of the sequence, i.e. that part not yet
	bound, looked up via nthnext .
      </p>

      <p>
	Finally, also optional, <codeph>:as</codeph> followed by a
	symbol will cause that symbol to be bound to the entire
	init-expr:
      </p>

      <codeblock>
(let [[a b c &amp; d :as e] [1 2 3 4 5 6 7]]
  [a b c d e])
 
->[1 2 3 (4 5 6 7) [1 2 3 4 5 6 7]]
      </codeblock>

      <p>These forms can be nested:</p>
      
      <codeblock>
(let [[[x1 y1][x2 y2]] [[1 2] [3 4]]]
  [x1 y1 x2 y2])
 
->[1 2 3 4]
      </codeblock>

      <p>Strings work too:</p>

      <codeblock>
(let [[a b &amp; c :as str] "asdjhhfdas"]
  [a b c str])
 
->[\a \s (\d \j \h \h \f \d \a \s) "asdjhhfdas"]
      </codeblock>

    </section>

    <section>
      <title>Map Destructuring</title>

      <p>
	Map binding-forms allow you to bind names to parts of
	associative things (not just maps), like maps, vectors, string
	and arrays (the latter three have integer keys). It consists
	of a map of binding-form-key pairs, each symbol being bound to
	the value in the init-expr at the key. In addition, and
	optionally, an :as key in the binding form followed by a
	symbol will cause that symbol to be bound to the entire
	init-expr. Also optionally, an :or key in the binding form
	followed by another map may be used to supply default values
	for some or all of the keys if they are not found in the
	init-expr:
      </p>

      <codeblock>
      (let [{a :a, b :b, c :c, :as m :or {a 2 b 3}} {:a 5
	:c 6}] [a b c m])
	->[5 3 6 {:c 6, :a 5}]
      </codeblock>

      <p>
	It is often the case that you will want to bind same-named
	symbols to the map keys. The :keys directive allows you to
	avoid the redundancy: <codeph>(let [{fred :fred ethel :ethel lucy :lucy} m] ...</codeph>
	can be written: <codeph>(let [{:keys [fred ethel lucy]} m] ...</codeph>
      </p>

      <p>
	As of Clojure 1.6, you can also use prefixed map keys in the map destructuring form:
      </p>

      <codeblock>
(let [m {:x/a 1, :y/b 2}
      {:keys [x/a y/b]} m]
  (+ a b))
 
-> 3
      </codeblock>

      <p>
	As shown above, in the case of using prefixed keys, the bound
	symbol name will be the same as the right-hand side of the
	prefixed key. You can also use auto-resolved keyword forms in
	the :keys directive:
      </p>

      <codeblock>
(let [m {::x 42}
      {:keys [::x]} m]
  x)
 
-> 42
      </codeblock>

      <p>
	There are similar :strs and :syms directives for matching
	string and symbol keys, the latter also allowing prefixed
	symbol keys since Clojure 1.6.
      </p>

    </section>

    <section>
      <title>Nested destructuring</title>

      <p>
	Since binding forms can be nested within one another
	arbitrarily, you can pull apart just about anything:
      </p>

      <codeblock>
(let [{j :j, k :k, i :i, [r s &amp; t :as v] :ivec, :or {i 12 j 13}}
      {:j 15 :k 16 :ivec [22 23 24 25]}]
  [i j k r s t v])
 
-> [12 15 16 22 23 (24 25) [22 23 24 25]]	
      </codeblock>
    </section>

  </body>

  <related-links>
    <!-- <link href="foo.dita"> -->
    <!--   <linktext/> -->
    <!-- </link> -->
  </related-links>
</topic>
